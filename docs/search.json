[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Basar Chowdhury"
  },
  {
    "objectID": "posts/interview-prep/InterviewPrep.html",
    "href": "posts/interview-prep/InterviewPrep.html",
    "title": "Random Notes and Alogos",
    "section": "",
    "text": "def BinarySearchRecursive(nlist, target, low, high):\n  if (len(nlist) == 0) or (low == high):\n    return\n\n  mid = (low+high)//2\n  if nlist[mid] == target:\n    return mid\n  elif nlist[mid] &gt; target:\n    return BinarySearchRecursive(nlist, target, low, mid-1)\n  else:\n    return BinarySearchRecursive(nlist, target, mid+1, high)\n  return None\n\n\nnlist = [1,2,3, 4, 6, 7, 9, 10, 12, 13, 14]\nBinarySearchRecursive(nlist, 3, 0, len(nlist)-1) == 2\n\n\nTrue\n\n\n\ndef BinarySearch(nlist, x):\n  if len(nlist) == 0: return None\n  low, high = 0, len(nlist)\n  while low &lt;= high:\n    mid = (low+high)//2\n    if nlist[mid] == x:\n      return mid\n    elif x &lt; nlist[mid]:\n      high = mid-1\n    else:\n      low = mid+1\n  return None\n\nx = BinarySearch(nlist, 3) == BinarySearchRecursive(nlist, 3, 0, len(nlist)-1)\ny = BinarySearch([1,3,3], 3)\nz = BinarySearch([1,2,4,8,13], 8)\nprint(x, y, z)\n\nTrue 1 3\n\n\n\n10//2\n\n5\n\n\n\n9//2\n\n4\n\n\n\ndef contains_unique(nums):\n    xor_result = 0\n    for num in nums:\n        xor_result ^= num\n    print(xor_result)\n    return xor_result != 0\n\n\narray = [1, 2, 2, 3, 3, 4, 4, 5]\ncontains_dup = contains_unique(array)\nprint(f\"The array contains uinque element: {contains_dup}\")\n\n4\nThe array contains uinque element: True\n\n\n\nN = 20\nwhile N:\n  t = N\n  t1 = N-1\n  N = t & t1\n  print(bin(t), bin(t1), bin(N))\n\n0b10100 0b10011 0b10000\n0b10000 0b1111 0b0\n\n\n\nimport math\na = -1 %  10\nprint(a)\ndigit = int(math.fmod(-1, 10))\nprint(digit)\n\nx = int(-1 / 10)\nprint(x)\n\n9\n-1\n0"
  },
  {
    "objectID": "posts/interview-prep/InterviewPrep.html#array",
    "href": "posts/interview-prep/InterviewPrep.html#array",
    "title": "Random Notes and Alogos",
    "section": "Array",
    "text": "Array\n\nLeet code 33. Search in Rotated Sorted Array\n\ndef BinarySearch(a, x):\n  if len(a) == 0: return None\n  l, h = 0, len(a)-1\n\n  while l &lt;= h:\n    mid = (l+h) // 2\n    if a[mid]==x: return mid\n\n    ## array to the left of the mid is sorted\n    if a[l] &lt;= a[mid]:\n      if a[l] &lt;= x &lt;= a[mid]:\n        h = (mid-1)\n      else:\n        l = (mid+1)\n    else:\n      if a[mid] &lt;= x &lt;= a[h]:\n        l = mid+1\n      else:\n        h = mid-1\n  return None\n\n\nBinarySearch([3,4,4,5,6,1,2,3], 6)\n\n4\n\n\n\n\n11. Container With Most Water\n\ndef maxArea(self, height) -&gt; int:\n        l, r = 0, len(height)-1\n        maxarea = float(\"-inf\")\n        while l &lt; r:\n            cmax = min(height[l], height[r]) * (r-l)\n            maxarea = max(cmax, maxarea)\n\n            if height[r] &lt; height[l]:\n                r = r-1\n            else:\n                l = l+1\n        return maxarea\n\n\n\n153. Find Minimum in Rotated Sorted Array\n\ndef FindMinInRotatedList(a):\n  l, r = 0, len(a)-1\n  while l &lt; r:\n    m = (l + r)//2\n    if a[m] &gt; a[r]:\n      l = m + 1\n    else:\n      r = m\n  return a[l]\n\nFindMinInRotatedList([3,1,2])\n\n1\n\n\n\n\n152. Maximum Product Subarray\n\ndef FindMaxSubArrayProduct(a):\n  mx = float(\"-inf\")\n  cm = 1\n  for i in a:\n    ocm = cm\n    cm = max(cm, cm*i)\n    if ocm &gt; cm:\n      cm = i\n    mx = max(mx, cm)\n  return mx\n\nFindMaxSubArrayProduct([2,3,-12,4, 8])\n\n192\n\n\n\ndef decimal_to_binary(n):\n  if n &lt; 2: return n\n  return 10 * decimal_to_binary(n//2) + n%2\n\ndecimal_to_binary(3)\n\n11\n\n\n\ndef tower_of_hanoi(n, from_rod, to_rod, aux_rod):\n  if n==0: return\n  tower_of_hanoi(n-1, from_rod, aux_rod, to_rod)\n  print(\"moved disk {0} from {1} to rod {2}\".format(n, from_rod, to_rod))\n  tower_of_hanoi(n-1, aux_rod, to_rod, from_rod)\n\ntower_of_hanoi(4, 'A', 'B', 'C')\n\nmoved disk 1 from A to rod C\nmoved disk 2 from A to rod B\nmoved disk 1 from C to rod B\nmoved disk 3 from A to rod C\nmoved disk 1 from B to rod A\nmoved disk 2 from B to rod C\nmoved disk 1 from A to rod C\nmoved disk 4 from A to rod B\nmoved disk 1 from C to rod B\nmoved disk 2 from C to rod A\nmoved disk 1 from B to rod A\nmoved disk 3 from C to rod B\nmoved disk 1 from A to rod C\nmoved disk 2 from A to rod B\nmoved disk 1 from C to rod B\n\n\n\ndef insertion_sort(nums):\n  N = len(nums)\n  for i in range(N):\n    j = i\n    ## move the current number to its correct position in the left side\n    while j &gt; 0 and nums[j-1] &gt; nums[j]:\n      nums[j-1], nums[j] = nums[j], nums[j-1]\n      j -= 1\n  return nums\n\nnums = [2,5,3,4,5,-5,3,45,34]\ninsertion_sort(nums)\n\n\n# Space: O(1)\n# Time: O(n^2)\n\n[-5, 2, 3, 3, 4, 5, 5, 34, 45]\n\n\n\ndef binsearch_weakest(nums, t):\n  l, r = 0, len(nums)-1\n  idx = r\n  while l&lt;=r:\n    m = l + (r-l)//2\n    if t &lt;= nums[m]:\n      r = m - 1\n      idx = m\n    else:\n      l = m + 1\n  return idx\n\nnums = [1,2,2,2,2,3,3,4,5,6,7]\nbinsearch_weakest(nums, 3)\n\n5\n\n\n\nimport heapq\nfrom builtins import iter\n\n\ndef merge_sorted_arrays(arrs):\n  min_heap = []\n  sorted_arrays_iter = [ iter(i) for i in arrs ]\n\n  ## build the heap\n  for i, t in enumerate(sorted_arrays_iter):\n    fe = next(t, None)\n    if fe: heapq.heappush(min_heap, (fe, i))\n\n  res = []\n  while min_heap:\n    s_elem, s_arr_i = heapq.heappop(min_heap)\n    res.append(s_elem)\n    next_elem = next(sorted_arrays_iter[s_arr_i], None)\n    if next_elem:\n      heapq.heappush(min_heap, (next_elem,s_arr_i))\n  return res\n\narrs = [[-100, -99, -1], [1,2,3,4], [100, 101, 102]]\nans = merge_sorted_arrays(arrs)\nprint(ans)\n\n[-100, -99, -1, 1, 2, 3, 4, 100, 101, 102]\n\n\n\ndef bin_search_last(arrs, t):\n  l, r = 0, len(arrs)-1\n  res = -1\n\n  while l &lt;= r:\n    m = l + (r-l)//2\n    if arrs[m] &lt; t:\n      l = m + 1\n    elif arrs[m] &gt; t:\n      r = m - 1\n    else:\n      res = m\n      l = m + 1\n  return res\n\ndef bin_search_first(arrs, t):\n  l, r = 0, len(arrs)-1\n  res = -1\n\n  while l &lt;= r:\n    m = l + (r-l)//2\n    if arrs[m] &lt; t:\n      l = m + 1\n    elif arrs[m] &gt; t:\n      r = m - 1\n    else:\n      res = m\n      r = m - 1\n  return res\n\n[1,2,3,4,5,5,5,5,6]\n\nf = bin_search_last([2,2,3,3,4,4,4,4], 4)\nl = bin_search_first([2,2,3,3,4,4,4,4], 4)\nprint(f, l)\n\n7 4\n\n\n\ndef wordPtr(warr = [\"data\", \"data2\"]):\n  print(warr[0][1])\n\nwordPtr()\n\na\n\n\n\nnums = [1,2,3,4,5,6]\nnums[:2]\n\n[1, 2]\n\n\n\ndef find_next_target(nums, t):\n  l, r = 0, len(nums)-1\n  while l &lt;= r:\n    m = l + (r-l)//2\n    if nums[m] &lt;= t:\n      l = m + 1\n    else:\n      r = m - 1\n  return nums[l%len(nums)]\n\nnums = [1,2,3,4,5,6,7,8]\nfind_next_target(nums, 2)\n\n3\n\n\n\ndef search_target_range(nums, k):\n  l, r = 0, len(nums)-1\n  tl, tr = -1, -1\n\n  while l &lt;= r:\n    m = l + (r-l)//2\n    if nums[m] == k:\n      l = m + 1\n      tr = m\n    elif nums[m] &lt; k :\n      l = m + 1\n    else:\n      r = m - 1\n\n  l, r = 0, len(nums)-1\n  while l &lt;= r:\n    m = l + (r-l)//2\n    if nums[m] == k:\n      r = m - 1\n      tl = m\n    elif nums[m] &lt; k:\n      l = m + 1\n    else:\n      r = m-1\n\n\n  return [tl, tr]\n\n\nnums = [1,2,3,4,5,6,6,6,7,8]\nsearch_target_range(nums, 6)\n\n[5, 7]\n\n\n\nz = zip(\"hel\", \"hello\")\nfor i in z:\n  print(i)\n\n('h', 'h')\n('e', 'e')\n('l', 'l')\n\n\n\nfor place,term in enumerate(('Thousand', 'Million', 'Billion'), 1):\n  print(place, term)\n\n1 Thousand\n2 Million\n3 Billion\n\n\n\nnums = [23,2,4,6,7]\np_s = -1\nk = 6\nfor i in range(len(nums)):\n  p_s += nums[i]\n  if k != 0:\n    p_s = p_s%k\n  print(p_s)\n\ns = \"\".join([\"1\", \"2\", \"3\"])\nmemoryview(b's')\n\n4\n0\n4\n4\n5\n\n\n&lt;memory at 0x1060328c0&gt;\n\n\n\ndata = \"tadataisdata\"\nidx = data.find(\"da\")\ndata = data[2+len(\"da\"):]\nprint(data)\n\ntaisdata\n\n\n\ndata = \"abcd\"\nfor i in range(len(data)):\n  print(data[:i] + \"*\" + data[i+1:])\n\n*bcd\na*cd\nab*d\nabc*\n\n\n\nimport time\nimport random\ndef generate_uid():\n  tstamp = int(time.time())\n  random_five_bytes = random.getrandbits(40).to_bytes(5, 'big')\n  counter_three_byte = random.randint(0, 0xFFFFFF).to_bytes(3, 'big')\n  uid_bytes = tstamp.to_bytes(4, 'big') + random_five_bytes + counter_three_byte\n  uid_hex = uid_bytes.hex()\n  return uid_hex\n\ngenerate_uid()\n\n'66aa804727708175999aac03'\n\n\n\ndata = set()\ndata.add(1)\ndata.add(2)\ndata.add(3)\ndata.add(4)\nprint(data)\n\n{1, 2, 3, 4}\n\n\n\ndef subarraySumPartition(nums, k):\n\n  dp = {}\n\n  def helper(i, m):\n    if m == 1:\n      return sum(nums[i:])\n\n    if (i, m) in dp: return dp[(i, m)]\n\n    res, csum = float(\"inf\"), 0\n    for i in range(i, len(nums)-m+1):\n      csum += nums[i]\n      maxsum = max(csum, helper(i+1, m-1))\n      res = min(res, maxsum)\n      if csum &gt; res:\n        continue\n    dp[(i, m)] = res\n    return res\n\n  return helper(0, k)\n\nnums = [7,2,5,10,8]\nk = 2\nsubarraySumPartition(nums, k)\n\n18\n\n\n\ndef findClosesInSorted(nums, t):\n  l, r = 0, len(nums)-1\n  while l &lt;= r:\n    m = l + (r-l)//2\n    if nums[m] == t: return m\n    elif nums[m] &lt; t:\n      l = m+1\n    else:\n      r = m-1\n\n  if l &gt;= len(nums):\n    return r\n  ld, rd = abs(t-nums[l]), abs(t-nums[r])\n  return l if ld &lt; rd else r\n\nnums = [1,10, 20, 30, 40, 50]\nt = 30\n\nidx = findClosesInSorted(nums, t)\nprint(idx, nums[idx])\n\n3 30\n\n\n\nfrom bisect import *\nnums = [1,10, 20, 30, 30, 30, 30, 40, 50]\nb = bisect_right(nums, 30)\na = bisect_left(nums, 30)\nprint(b, a)\n\n7 3\n\n\n\ndef canShip(cap, weights):\n  cw = 0\n  ships = 0\n  for w in weights:\n    if cw - w &lt; 0:\n      ships += 1\n      cw = cap\n    cw -= w\n\n  return ships\n\nweights = [1, 2, 3, 4, 5]\ncanShip(9, weights)\n\n2\n\n\n\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\n'''\n\n'''\n\n'\\n\\n'\n\n\n\ndef missingKthPositive(arr, k):\n  l, r = 0, len(arr)-1\n  while l &lt;= r:\n    p = l + (r-l)//2\n    print(p)\n    if arr[p] - p - 1 &lt; k:\n      l = p + 1\n    else:\n      r = p - 1\n\n  return l, r\n\nnums = [2,3,4,7,11]\nprint(missingKthPositive(nums, 5))\n\n'''\n[2,3,4,7,11]\n1, 5, 6, 8 , 9\n7 - 4 = 3\n\n11 - 5 = 6\n4 + 5 = 9\n3\n\n0 1 2 3 4 5\n\n\n'''\n\n2\n3\n4\n(4, 3)\n\n\n'\\n[2,3,4,7,11]\\n1, 5, 6, 8 , 9\\n7 - 4 = 3\\n\\n11 - 5 = 6\\n4 + 5 = 9\\n3\\n\\n0 1 2 3 4 5\\n\\n\\n'\n\n\n\nprices = [2,3,4,5,6,7,8]\nfor i, p in reversed(list(enumerate(prices[1:], 1))):\n  print(i, p)\n\n6 8\n5 7\n4 6\n3 5\n2 4\n1 3\n\n\n\nfrom random import randint\nres = 0\nfor i in range(randint(0, 10)):\n  res = max(res, randint(0, 100))\n  print(res)\n\n81\n87\n87\n93\n93\n\n\n\ndata = {'a' : 0, 'b' : -1, 'c' : 0}\nprint()\n\n\n\n\n\nnums = [2, 9, 6, 5, 4, 3, 78, 56, 23]\ndef rearrange(nums):\n  N = len(nums)\n  for i in range(N):\n    nums[i:i+2] = sorted(nums[i:i+2], reverse=(i%2))\n    print(i%2, bool(i%2))\n\n  print(nums)\n\nrearrange(nums)\n\n0 False\n1 True\n0 False\n1 True\n0 False\n1 True\n0 False\n1 True\n0 False\n[2, 9, 5, 6, 3, 78, 4, 56, 23]\n\n\n\ndef generatePrime(n):\n  primes = []\n  isPrime = [False, False] + [True] * (n-1)\n  for p in range(2, n+1):\n    if isPrime[p]:\n      primes.append(p)\n      for i in range(p*2, n+1, p):\n        isPrime[i] = False\n\n  return primes\n\ngeneratePrime(100)\n\n[2,\n 3,\n 5,\n 7,\n 11,\n 13,\n 17,\n 19,\n 23,\n 29,\n 31,\n 37,\n 41,\n 43,\n 47,\n 53,\n 59,\n 61,\n 67,\n 71,\n 73,\n 79,\n 83,\n 89,\n 97]\n\n\n\ndef printBreaks(s):\n  for i in range(len(s)+1):\n    print(s[0:i])\n\nprintBreaks(\"leetcode\")\n\n\nl\nle\nlee\nleet\nleetc\nleetco\nleetcod\nleetcode\n\n\n\na = 10\na.bit_length()\nhelp(a.bit_length)\n\nHelp on built-in function bit_length:\n\nbit_length() method of builtins.int instance\n    Number of bits necessary to represent self in binary.\n\n    &gt;&gt;&gt; bin(37)\n    '0b100101'\n    &gt;&gt;&gt; (37).bit_length()\n    6\n\n\n\n\nd = \"The game is on\"\nprint(d.split())\n\n['The', 'game', 'is', 'on']\n\n\n\nword = \"goat\"\nw = word[1:] + word[0]\nw\n\n'oatg'\n\n\n\nclass TrieNode():\n\n  def __init__(self):\n    self.children = {}\n    self.isWord = False\n\nclass Trie():\n\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word):\n    cur = self.root\n    for c in word:\n      if c not in cur.children:\n        cur.children[c] = TrieNode()\n      cur = cur.children[c]\n\n    cur.isWord = True\n    print(cur)\n\n  def startsWith(self, word):\n    cur = self.root\n    for c in word:\n      if c not in cur.children:\n        return False\n      cur = cur.children[c]\n    return True\n\n  def search(self, word):\n    cur = self.root\n    for c in word:\n      if c not in cur.children:\n        return False\n      cur = cur.children[c]\n\n    return cur.isWord\n\n\n\nt = Trie()\nt.insert(\"apple\")\nprint(t.search(\"apple\"))\nprint(t.startsWith(\"zz\"))\n\n&lt;__main__.TrieNode object at 0x10555a0c0&gt;\nTrue\nFalse\n\n\n\nclass Node():\n\n  def __init__(self, val=0):\n    self.val = val\n    self.left = None\n    self.right = None\n\n\nn = Node()\nn.parent = Node(12)\n\nprint(n.parent.val)\n\n12\n\n\n\ndef binExp(x, n):\n  res = 1\n  while n &gt; 0:\n    if n%2 == 1:\n      print(x, n, res, \"--&gt;\", end=\"\")\n      res *= x\n      n -= 1\n      print(x, n, res)\n    x *= x\n    n = n // 2\n  return res\n\nbinExp(2, 10)\n\n4 5 1 --&gt;4 4 4\n256 1 4 --&gt;256 0 1024\n\n\n1024\n\n\n\ndef findPalindrome(word):\n  l, r = 0, len(word)-1\n  isLowerLetter = lambda x: ord('a') &lt;= ord(x.lower()) &lt;= ord('z')\n\n  while l &lt;= r:\n    while not (isLowerLetter(word[l])):\n      l += 1\n    while not (isLowerLetter(word[r]) ):\n      r -= 1\n    if word[l] != word[r]:\n      return False\n    l += 1\n    r -= 1\n  return True\n\n\nfindPalindrome(\"racecar\")\n\nTrue\n\n\n\nfrom functools import lru_cache\ndef findMaxProduct(n):\n  @lru_cache\n  def integerBreak(num):\n    if num &lt;= 3: return num\n    res = num\n    for i in range(2, num):\n      res = max(res, i * integerBreak(num-i))\n    return res\n  if n &lt;= 3: return n-1\n  return integerBreak(n)\n\n\nfindMaxProduct(16)\n\n324\n\n\n\n## (located on the number line at position Qx) = (Eqx/abs(Px-Qx))\n\ndef minEffectLocation(p, qlist):\n  minEffect, minLoc = float(\"inf\"), -1\n  for px in range(1, p-1):\n    effect = sum([ eqx / abs(px-qx) if (px-qx) != 0 else float(\"inf\") for eqx, qx in qlist ])\n    if effect &lt; minEffect:\n      minEffect = effect\n      minLoc = px\n  return minLoc\n\nminEffectLocation(5, [[10,0],[20,4]])\n\n2\n\n\n\ndef getDistintPasswordVariability(password):\n  if password == \"\": return 0\n  plen = len(password)\n\n  distinctPassword = set()\n\n  for i in range(plen):\n    for j in range(i, plen):\n      subStr = password[i:j+1][::-1]\n      npwd = password[:i] + subStr + password[i+1:]\n      distinctPassword.add(npwd)\n  return len(distinctPassword)\n\n\ngetDistintPasswordVariability(\"abc\")\n\n4\n\n\n\ns = \"abcdabc\"\nlastOcc = { c:i for i, c in enumerate(s) }\nprint(lastOcc)\n\n{'a': 4, 'b': 5, 'c': 6, 'd': 3}\n\n\n\ndef findFirstMatchingIndex(nums):\n  if not nums: return -1\n  l, r = 0, len(nums)-1\n\n  res = -1\n  while l &lt;= r:\n    m = l + (r-l)//2\n    if nums[m] - m &gt; 0:\n      r = m - 1\n    elif nums[m] - m &lt; 0:\n      l = m + 1\n    else:\n      res = m\n      r = m - 1\n\n  return res\n\nnums = [-8,0,1,3,5]\nfindFirstMatchingIndex(nums)\n\n\n### -2 1 2 3 4 100\n\n3\n\n\n\nclass DisjointSet():\n\n  def __init__(self, N):\n    self.parent = [i for i in range(N)]\n    self.rank = [0 for i in range(N)]\n\n  def Union(self, u, v):\n    u = self.Find(u)\n    v = self.Find(v)\n\n    if u != v:\n      if self.rank[u] &lt; self.rank[v]:\n        u, v = v, u\n      self.parent[v] = u\n      if self.rank[u] == self.rank[v]:\n        self.rank[u] += 1\n\n\n\n  def Find(self, x):\n    if x == self.parent[x]: return x\n    self.parent[x] = self.Find(self.parent[x])\n    return self.parent[x]\n\n\nd = DisjointSet(5)\nd.Union(0, 1)\nd.Union(0, 2)\nd.Union(3, 4)\nprint(d.Find(2), d.Find(4))\nprint(d.rank)\n\n0 3\n[1, 0, 0, 1, 0]\n\n\n\nimport heapq\n\ndef MergeSortedArray(sortedArr):\n  minHeap = []\n  sortedIter = [ iter(x) for x in sortedArr]\n\n  for i, it in enumerate(sortedIter):\n    felem = next(it)\n    if next is not None:\n      heapq.heappush(minHeap, (felem, i))\n\n  res = []\n  while minHeap:\n    nelem, idx = heapq.heappop(minHeap)\n    res.append(nelem)\n    nextItem = next(sortedIter[idx], None)\n    if nextItem: heapq.heappush(minHeap, (nextItem, idx))\n\n  return res\n\nMergeSortedArray([[1,3,5,7,9], [2,4,6,8,10]])\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\n\ndef FindSelfDrivingWays(n):\n\n  def isValid(r, c):\n    if not (0 &lt;= r &lt; ROWS): return False\n    if not (0 &lt;= c &lt; COLS): return False\n    if r &lt; c: return False\n    return True\n\n  memo = {}\n  def dfs(r, c, sol=[]):\n    if not isValid(r,c): return 0\n    if r == ROWS-1 and c == COLS-1:\n      sol.append((r, c))\n      print(sol.copy())\n      return 1\n\n    if (r, c) in memo:\n      sol.append((r, c))\n      print(sol.copy())\n      return memo[(r, c)]\n\n    sol.append((r, c))\n    tcounts = 0\n    ## move north\n    nr, nc = r+1, c\n    if isValid(nr, nc):\n      tcounts += dfs(nr, nc, sol.copy())\n\n    ## move east\n    er, ec = r, c+1\n    if isValid(er, ec):\n      tcounts += dfs(er, ec, sol.copy())\n\n    memo[(r, c)] = tcounts\n    return tcounts\n\n  ROWS = COLS = n\n  return dfs(0, 0)\n\n\nFindSelfDrivingWays(5)\n\n[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)]\n[(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (4, 1)]\n[(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (3, 2), (4, 2)]\n[(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (3, 2), (3, 3), (4, 3)]\n[(0, 0), (1, 0), (2, 0), (2, 1), (3, 1)]\n[(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2)]\n[(0, 0), (1, 0), (1, 1), (2, 1)]\n\n\n14\n\n\n\ndef numOfPathsToDest(n):\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][0] = 1  # Initialize leftmost column to 1\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i &gt;= j:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][n-1]\n\nprint(numOfPathsToDest(5))\n\n14\n\n\n\ndef reverseInt(n):\n    ans = 0\n    while n:\n        cn = n % 10\n        ans = ans*10 + cn\n        n = n // 10\n    return ans\n\nprint(reverseInt(38976))\n\n67983\n\n\n\ndef TestLocalVar():\n  def inc():\n    nonlocal count\n    count += 1\n\n  count = 0\n  inc()\n  inc()\n  inc()\n  return count\n\nTestLocalVar()\n\n3\n\n\n\ndata = \"a, a, a, a, b,b,b,c, c\"\ndata.split()\n\ndef isChar(c):\n  if ord('a') &lt;= ord(c.lower()) &lt;= ord('z'): return True\n  return False\n\ndef replacePuntuation(word):\n  newWord = []\n  for w in word:\n    if isChar(w): newWord.append(w)\n  return \"\".join(newWord).lower()\n\nwlist = [replacePuntuation(w) for w in data.split()]\n\nprint(wlist)\n\n['a', 'a', 'a', 'a', 'bbbc', 'c']\n\n\n\n\nimport collections\nimport bisect\n\nclass FileSystem:\n\n    def __init__(self):\n        self.paths = collections.defaultdict(list)\n        self.files = collections.defaultdict(str)\n\n\n    def ls(self, path: str):\n        if path in self.files:\n            return [ path.split(\"/\")[-1] ]\n\n        return self.paths[path]\n\n\n    def mkdir(self, path: str) -&gt; None:\n        dirs = path.split(\"/\")\n        for d in range(1, len(dirs)):\n            curDir = \"/\".join(dirs[:d]) or \"/\"\n            if curDir not in self.paths or dirs[d] not in self.paths[curDir]:\n                bisect.insort(self.paths[curDir], dirs[d])\n\n\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        if filePath not in self.files:\n            self.mkdir(filePath)\n        self.files[filePath] += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        return self.files[filePath]\n\n    def printData(self):\n      print(self.paths)\n      print(self.files)\n\n\n\n\n\nfileSystem = FileSystem();\nfileSystem.ls(\"/\");\nfileSystem.mkdir(\"/a/b/c\");\nfileSystem.mkdir(\"/a/a/b/c\");\nfileSystem.mkdir(\"/a/m\");\n\n\nfileSystem.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(fileSystem.ls(\"/a\"))\nprint(fileSystem.readContentFromFile(\"/a/b/c/d\"))\nfileSystem.printData()\n\n['a', 'b', 'm']\nhello\ndefaultdict(&lt;class 'list'&gt;, {'/': ['a'], '/a': ['a', 'b', 'm'], '/a/b': ['c'], '/a/a': ['b'], '/a/a/b': ['c'], '/a/b/c': ['d']})\ndefaultdict(&lt;class 'str'&gt;, {'/a/b/c/d': 'hello'})\n\n\n\ndef count_k_big_indices(nums, k):\n    n = len(nums)\n    left = [0] * n\n    right = [0] * n\n    stack = []\n\n    for i in range(n):\n        while stack and nums[stack[-1]] &lt; nums[i]:\n            stack.pop()\n        if stack:\n            left[i] = stack[-1] + 1\n        stack.append(i)\n\n    stack = []\n    for i in range(n - 1, -1, -1):\n        while stack and nums[stack[-1]] &lt; nums[i]:\n            stack.pop()\n        if stack:\n            right[i] = stack[-1] - 1\n        stack.append(i)\n\n    count = 0\n    for i in range(n):\n        if right[i] &gt;= k and left[i] &gt;= k:\n            count += 1\n\n    print(left, right)\n    return count\n\n# Example usage\nnums = [2, 3, 6, 5, 2, 3]\nk = 2\nprint(count_k_big_indices(nums, k))  # Output: 2\n\n[0, 0, 0, 3, 4, 4] [0, 1, 0, 0, 4, 0]\n1\n\n\n\ndef max_subsequence_sum(nums, k):\n    max_sum = float('-inf')\n    max_start = 0\n\n    # Calculate the sum of the first subsequence of length k\n    current_sum = sum(nums[:k])\n    max_sum = current_sum\n\n    # Iterate through the remaining subsequences of length k\n    for i in range(1, len(nums) - k + 1):\n        # Update the current sum by adding the next element and subtracting the first element\n        current_sum = current_sum - nums[i - 1] + nums[i + k - 1]\n        # Update the maximum sum and the starting index of the subsequence\n        if current_sum &gt; max_sum:\n            max_sum = current_sum\n            max_start = i\n\n    # Return the subsequence with the maximum sum\n    return nums[max_start:max_start + k]\n\n# Test the function\nnums1 = [2, 1, 3, 3]\nk1 = 2\nprint(max_subsequence_sum(nums1, k1))  # Output should be [3, 3]\n\nnums2 = [-1, -2, 3, 4]\nk2 = 3\nprint(max_subsequence_sum(nums2, k2))  # Output should be [-1, 3, 4]\n\n\n[3, 3]\n[-2, 3, 4]\n\n\n\ndef Bisect(n, arr):\n  l, r = 0, len(arr)-1\n\n  res = -1\n  while l &lt;= r:\n    m = l + (r-l)//2\n    if arr[m] &gt;= n:\n      r = m - 1\n    else:\n      l = m + 1\n\n  return l, r\n\nBisect(45, [10,30,40,50,60])\n\n(3, 2)\n\n\n\nf = set([1,2,3])\ng = set([2,3])\nf-g\n\n{1}\n\n\n\ndef longestIncreasingPath(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n\n    ROWS, COLS = len(matrix), len(matrix[0])\n    neis = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    memo = {}\n\n    def validMove(r, c, pval):\n        return 0 &lt;= r &lt; ROWS and 0 &lt;= c &lt; COLS and matrix[r][c] &gt; pval\n\n    def dfs(r, c):\n        stack = [(r, c)]\n        path = 0\n\n        while stack:\n            cr, cc = stack[-1]\n            if (cr, cc) in memo:\n                path = max(path, memo[(cr, cc)])\n                stack.pop()\n                continue\n\n            memo[(cr, cc)] = 1\n            for x, y in neis:\n                nr, nc = cr + x, cc + y\n                if validMove(nr, nc, matrix[cr][cc]):\n                    stack.append((nr, nc))\n                    memo[(cr, cc)] = max(memo[(cr, cc)], path + 1)\n\n        return path\n\n    longestLen = 0\n    for r in range(ROWS):\n        for c in range(COLS):\n            longestLen = max(longestLen, dfs(r, c))\n\n    return longestLen\n\n# Example usage\nmatrix = [[9,9,4],[6,6,8],[2,1,1]]\nprint(longestIncreasingPath(matrix))  # Output: 4\n\n1\n\n\n\nimport heapq\nimport collections\n\nclass Solution:\n    def cutOffTree(self, forest):\n\n        def isValid(r, c):\n            return 0 &lt;= r &lt; ROWS and 0 &lt;= c &lt; COLS and forest[r][c]&gt;0\n\n        def bfs(sr, sc, tr, tc):\n            queue = collections.deque([(sr, sc, 0)])\n            visited = {(sr, sc)}\n            while queue:\n                cr,cc, steps = queue.popleft()\n                if cr==tr and cc==tc:\n                    forest[cr][cc] == 1. ## cut the tree\n                    return steps\n\n                for dr, dc in neis:\n                    nr, nc = cr+dr, cc+dc\n                    if (nr, nc) not in visited and isValid(nr, nc):\n                        visited.add((nr, nc))\n                        queue.append((nr, nc, steps+1))\n\n            return -1\n\n        neis = { (1, 0), (0, 1), (-1, 0), (0, -1) }\n        tsteps = 0\n        ROWS, COLS = len(forest), len(forest[0])\n        forestHeap = []\n        for r in range(ROWS):\n            for c in range(COLS):\n              if forest[r][c] &gt; 1:\n                heapq.heappush(forestHeap, (forest[r][c], r, c))\n\n        sr, sc = 0, 0\n        while forestHeap:\n            h, r, c = heapq.heappop(forestHeap)\n            spath = bfs(sr, sc, r, c)\n            if spath==-1: return spath\n            tsteps += spath\n            sr, sc = r, c\n\n        return tsteps\n\n\ns = Solution()\ns.cutOffTree([[1,2,3],[0,0,4],[7,6,5]])\n\n6\n\n\n\ndef BinaryDecimal(bstr):\n  d = 0\n  for i in bstr:\n    d = d*2 + int(i)\n  return d\n\nBinaryDecimal([\"1\", \"0\", \"0\"])\n\n4\n\n\n\nd = [3, 8, 48]\nfor i in range(len(d)):\n  for j in range(i+1, len(d)):\n    print(d[i], d[j], \"and &gt; \", d[i] & d[j])\n\n\n3 8 and &gt;  0\n3 48 and &gt;  0\n8 48 and &gt;  0\n\n\n\ndef FindMissingRange(nums):\n  l, u = nums[0], nums[-1]\n\n  res = \"\"\n  ## find any below given lower bound\n  mlarr = []\n  for i in range(0, l+1):\n    mlarr.append(str(i))\n\n  if len(mlarr) &gt; 2:\n    res + (str(mlarr[0])) + \"..\" + str(mlarr[-1])\n  else:\n    res += \", \".join(mlarr) if mlarr else \"\"\n\n  start = 0\n  for i in range(1, len(nums)):\n    tres = []\n    if nums[i] - nums[start] &gt; 1:\n      for j in range(start+1, i):\n        tres.append(str(j))\n      if len(tres) &gt; 2: res += str(tres[0]) + \"...\" + str(tres[-1])\n      else: res += \", \".join(tres)\n\n    start = i\n\n\n  muarr = []\n  for i in range(u, 100):\n    muarr.append(str(i))\n\n  if len(muarr) &gt; 2:\n    res + (str(muarr[0])) + \"..\" + str(muarr[-1])\n  else:\n    res += \", \".join(muarr) if muarr else \"\"\n\n  return res\n\n\nFindMissingRange([2, 3, 4, 98])\n\n'98, 99'\n\n\n\nfrom random import *\n\ndef FindKthSmallest(nums, k):\n  return quickSelect(nums, 0, len(nums)-1, k-1)\n\n\ndef partitions(nums, l, r):\n  pIdx = randint(l, r)\n  pval = nums[pIdx]\n  nums[r], nums[pIdx] = nums[pIdx], nums[r]\n  i = l\n  for j in range(l, r):\n    if nums[j] &lt; pval:\n      nums[i], nums[j] = nums[j], nums[i]\n      i += 1\n  nums[r], nums[i] = nums[i], nums[r]\n  return i\n\n\ndef quickSelect(nums, l, r, k):\n  if l==r:\n    return nums[l]\n\n  pIdx = partitions(nums, l, r)\n  if pIdx == k: return nums[pIdx]\n  elif pIdx &lt; k:\n    return quickSelect(nums, pIdx, r, k)\n  else:\n    return quickSelect(nums, l, pIdx, k)\n\n  return -1\n\n\n\nnums = [1,2,3,4,5,90,89,100]\nk = 6\nFindKthSmallest(nums, k)\n\n89\n\n\n\ndef RandomizeArray(nums):\n  for i in range(len(nums)-1, -1, -1):\n    j = randint(0, i)\n    nums[i], nums[j] = nums[j], nums[i]\n  return nums\n\nRandomizeArray([1, 2, 3, 4, 5])\n\n[5, 2, 3, 1, 4]\n\n\n\ndef FindUniqueIslands(matrix):\n\n  def isValid(r, c):\n    if not (0 &lt;= r &lt; ROWS) or  not (0 &lt;= c &lt; COLS) :\n      return False\n    return matrix[r][c] == 1\n\n\n  def _getHash(hashList):\n    h = [str(dr)+str(dc) for dr, dc in hashList]\n    return '_'.join(h)\n\n  def dfs(r, c):\n    stack = [ ((r, c), [0, 0])]\n    hash = []\n    while stack:\n      cinfo, dinfo = stack.pop()\n      cr, cc = cinfo\n      dinfoR, dinfoC = dinfo\n\n      visited.add((cr, cc))\n      hash.append([dinfoR, dinfoC])\n\n      for dr, dc in dirs:\n        nr, nc = cr+dr, cc+dc\n        if (nr, nc) not in visited and isValid(nr, nc):\n          ndinfo = [dr+dinfoR, dc+dinfoC]\n          stack.append(((nr, nc),  ndinfo))\n\n    return _getHash(hash)\n\n\n  dirs = { (1, 0), (-1, 0), (0, 1), (0, -1) }\n  visited = set()\n  uniqueIslands = set()\n  ROWS, COLS = len(matrix), len(matrix[0])\n\n  for r in range(ROWS):\n    for c in range(COLS):\n      if (r, c) not in visited and matrix[r][c] == 1:\n        iHash = dfs(r, c)\n        uniqueIslands.add(iHash)\n\n  return uniqueIslands\n\n\ngrid = [\n    [1, 1, 0, 0],\n    [1, 0, 0, 0],\n    [0, 0, 0, 1],\n    [0, 0, 0, 1],\n    [1, 0, 0, 0],\n    [1, 0, 0, 0]\n]\nu = FindUniqueIslands(grid)\nprint(u, len(u))\n\n{'00_01_10', '00_10'} 2\n\n\n\nfrom random import *\n\ndef KthSmallestElement(nums, k):\n\n  def partition(nums, l, r):\n    pidx = randint(l, r)\n    pval = nums[pidx]\n    nums[r], nums[pidx] = nums[pidx], nums[r]\n    i = l\n    for j in range(l, r):\n      if nums[j] &lt; pval:\n        nums[i], nums[j] = nums[j], nums[i]\n        i += 1\n\n    nums[i], nums[r] = nums[r], nums[i]\n    return pidx\n\n  def quickSelect(nums, l, r):\n    if l == r:\n      return nums[l]\n\n    idx = partition(nums, l, r)\n    if idx == k: return nums[idx]\n    elif idx &lt; k:\n      return quickSelect(nums, idx+1, r)\n    else:\n      return quickSelect(nums, l, idx-1)\n\n    return -1\n\n  return quickSelect(nums, 0, len(nums)-1)\n\n\nnums = [1, 2, 3, 4, 5, 100, 101]\n\nk = 3\nKthSmallestElement(nums, k-1)\n\n3\n\n\n\n'''\nInput: files = [ \"/webapp/assets/html/a.html\", \"/webapp/assets/html/b.html\", \"/webapp/assets/js/c.js\", \"/webapp/index.html\" ]\n\ndirs = {\n  \"webapp: [assets, js],\n  \"assets\": [html],\n  \"js: []\n}\n\nfiles = {\n}\n\n\n'''\n\n\nclass TrieNode:\n\n  def __init__(self, n):\n    self.children = {}\n    self.name = n\n\nclass Trie:\n\n  def __init__(self):\n    self.root = TrieNode(\"root\")\n\n  def insert(self, filePath):\n    files = filePath.split(\"/\")[1:]\n    cnode = self.root\n    for file in files:\n      if file not in cnode.children:\n        cnode.children[file] = TrieNode(file)\n      cnode = cnode.children[file]\n\n  def printDfs(self, node, indent):\n    if not node.children:\n      print(indent, \"--\", node.name)\n      return\n\n    print(indent, \"|\", node.name)\n    for d in node.children.values():\n      self.printDfs(d, indent*2)\n\n  def printAllLs(self):\n    self.printDfs(self.root, \" \")\n\n\nfiles = [ \"/webapp/assets/html/a.html\", \"/webapp/assets/html/b.html\", \"/webapp/assets/js/c.js\", \"/webapp/index.html\" ]\nt = Trie()\nfor f in files:\n  t.insert(f)\n\nt.printAllLs()\n\n  | root\n   | webapp\n     | assets\n         | html\n                 -- a.html\n                 -- b.html\n         | js\n                 -- c.js\n     -- index.html\n\n\n\ndef SearchMaxLen(nums):\n\n  def helper(cnum, clen):\n    '''\n      Returns the count of the sequence starting from cnum\n      cnum: stating count\n      clen: size of the current counts\n    '''\n    if cnum+1 not in cache: return clen\n    memo[cnum] = helper(cnum+1, clen+1)\n    return memo[cnum]\n\n  cache = set(nums)\n  mlen = 1\n  memo = {}\n  for n in nums:\n    if n-1 not in cache:\n      mlen = max(mlen, helper(n, 1))\n\n  return mlen\n\n\nnums = [1, 2, 3, 4, 5, 100, 101, 102, 103, 104, 105, 106, 107, 89]\nSearchMaxLen(nums)\n\n8\n\n\n\\(\\sqrt{\\alpha_1 + \\frac{\\beta}{\\gamma}}\\)\n\ndef JustifyWithHiphen(s, maxLen):\n  n = len(s)\n  res = []\n  i = 0\n  while i &lt; n-1:\n    opt1 = s[i] + \"-\" + s[i+1]\n    opt2 = s[i] + \"-\"\n    opt3 = s[i]\n    if len(opt1) &lt;= maxLen:\n      res.append(opt1)\n      i += 2\n    elif len(opt2) &lt;= maxLen:\n      res.append(opt2)\n      i += 1\n    else:\n      res.append(opt3)\n      i += 1\n\n  if i != n:\n    res.append(s[i])\n\n  return res\n\ns = [\"1p3acres\", \"is\", \"a\", \"good\", \"place\", \"to\", \"communicate\"]\na = 12\nJustifyWithHiphen(s, a)\n\n['1p3acres-is', 'a-good', 'place-to', 'communicate']\n\n\n\nfrom collections import Counter\n\ndef FindMaxDuplicate(nums, x, y , z):\n\n\n  def helper(idx, clist):\n    if idx == n:\n      maxdup = max(Counter(clist).values())\n      return maxdup\n\n    xop = nums[idx] + x\n    yop = nums[idx] - y\n    zop = nums[idx] * z\n    nop = nums[idx]\n    return max(\n        helper(idx+1, clist.copy() + [xop]),\n        helper(idx+1, clist.copy() + [yop]),\n        helper(idx+1, clist.copy() + [zop]),\n        helper(idx+1, clist.copy() + [nop]),\n        )\n\n  n = len(nums)\n  return helper(0, [])\n\nFindMaxDuplicate([1, 2, 6, 6, 5, 6], 1, 1, 1)\n\n4\n\n\n\ndef AddBinary(b1, b2):\n  m, n = list(b1), list(b2)\n  r, c = \"\", 0\n  while m and n:\n    a, b = int(m.pop()), int(n.pop())\n    r = str((a+b+c) % 2) + r\n    c += (a+b) // 2\n\n\n\n  while c &gt; 0:\n    r = str(c%2) + r\n    c = c // 2\n  return r\n\nAddBinary(\"11\", \"11\")\n\n'1010'\n\n\n\ndef findLength(nums1, nums2) -&gt; int:\n        def helper(i, j, cmax):\n            if i==m or j==n:\n                return cmax\n            print(i, j, nums1[i], nums2[j])\n            if (i, j) in memo: return memo[(i, j)]\n            if nums1[i] == nums2[j]:\n                memo[(i, j)] = helper(i+1, j+1, cmax+1)\n                return memo[(i, j)]\n\n            memo[(i, j)] = max( helper(i+1, j, 0), helper(i, j+1, 0), cmax )\n            return memo[(i, j)]\n\n        memo = {}\n        m, n = len(nums1), len(nums2)\n        return helper(0, 0, 0)\n\nnums1 = [-9, 1, 12, 12, 12]\nnums2 = [0, 1, 13, 13, 13]\n# findLength(nums1, nums2)\n\n\n\nclass Node():\n\n  def __init__(self,  k=None, v=None) -&gt; None:\n    self.key, self.value = k, v\n    self.prev = None\n    self.next = None\n\n\nclass LRUCache():\n\n  def __init__(self, cap):\n    self.capacity = cap\n    self.left, self.right = Node(), Node()\n    self.left.next, self.right.prev = self.right, self.left\n    self.cache = {} ## (key, nodeRef)\n\n\n  def _remove(self, node):\n    nPrev, nNext = node.prev, node.next\n    nPrev.next = nNext\n    nNext.prev = nPrev\n\n  def _insert(self, node):\n    rPrev, nxt = self.right.prev, self.right\n    rPrev.next = nxt.prev = node\n    node.prev, node.next = rPrev, nxt\n\n\n  def Get(self, key):\n    if key in self.cache:\n      node = self.cache[key]\n      self._remove(node)\n      self._insert(node)\n      return node.value\n\n    return -1\n\n\n  def Put(self, key, value):\n    if key in self.cache:\n      self._remove(self.cache[key])\n\n    self.cache[key] = Node(key, value)\n    self._insert(self.cache[key])\n\n    ## handle eviction\n    if self.capacity &lt; len(self.cache):\n      lru = self.left.next\n      self._remove(lru)\n      del self.cache[lru.key]\n\nlRUCache = LRUCache(2)\nlRUCache.Put(1, 1)\nlRUCache.Put(2, 2)\nprint(lRUCache.Get(1))\nlRUCache.Put(3, 3)\nprint(lRUCache.Get(2) )\nlRUCache.Put(4, 4)\nprint(lRUCache.Get(1))\nprint(lRUCache.Get(3))\nprint(lRUCache.Get(4))\n\n1\n-1\n-1\n3\n4\n\n\n\n'''\n\n[2,3,1,1,4]\n\n0 : idx\n\n'''\n\ndef FindMinJumps(nums):\n\n  def helper(idx):\n    if idx == n-1:\n      return 0\n\n    nxt = float(\"inf\")\n    for j in range(1, nums[idx]+1):\n      if idx + j &lt; n:\n        jumps = helper(idx+j)\n        nxt = min(nxt, jumps+1)\n\n    return nxt\n  n = len(nums)\n  return helper(0)\n\nFindMinJumps([2,3,1,1,4])\n\n2\n\n\n\nfrom collections import deque\n\ndata = [1, 2, 3, 4, 5]\nqueue = deque(data)\nwhile queue:\n  print(queue.popleft())\n\n1\n2\n3\n4\n5\n\n\n\nfrom collections import *\n\ndef FindMaxGiftsPossible(gifts):\n  gift = namedtuple('Gift', ['Day', 'Cost'])\n  glist = [ gift(d, c) for d, c in gifts ]\n  sortedGifts = sorted(glist, key=lambda x: x.Cost)\n  return sortedGifts\n\nitems = [(1, 100), (2, 101), (3, 0), (5, 1)]\nFindMaxGiftsPossible(items)\n\n[Gift(Day=3, Cost=0),\n Gift(Day=5, Cost=1),\n Gift(Day=1, Cost=100),\n Gift(Day=2, Cost=101)]\n\n\n\ndef LongestSubarraySum(nums):\n  if not nums: return None\n  cmax = gmax = nums[0]\n  for n in nums[1:]:\n    cmax = max(cmax+n, n)\n    gmax = max(gmax, cmax)\n  return gmax\n\nnums = [1, 100, 20, -9, 12, 89]\nLongestSubarraySum(nums)\n\n213\n\n\n\ndef MinimumJumpCount(nums):\n  if not nums: return 0\n  n = len(nums)\n\n  def helper(cidx, clen):\n    if cidx == n: return clen\n\n    njmp = float(\"inf\")\n    for j in nums[cidx+1:]:\n      if j+cidx &lt;= n:\n        njmp = min(njmp, helper(j+cidx, clen+1))\n\n    return njmp\n\n  return helper(0, 0)\n\njumps = [2, 3, 1, 1, 4]\nMinimumJumpCount(jumps)\n\n\n2\n\n\n\nfrom random import randint\n\nclass OptGetRandom:\n\n  def __init__(self):\n    self.cache = {}  ## stores, value, idx of the value in available list\n    self.availableList = []\n\n  def insert(self, v):\n    if v in self.cache: return\n    self.availableList.append(v)\n    self.cache[v] = len(self.availableList)-1\n\n  def remove(self, v):\n    if v not in self.cache: return\n    idx = self.cache[v]\n    n = len(self.availableList)\n    self.availableList[idx], self.availableList[n-1] = self.availableList[n-1], self.availableList[idx]\n\n    ## update the swaped last idx for cache\n    self.cache[self.availableList[idx]] = idx\n\n    ## remove from list and hashMap\n    del self.cache[v]\n    self.availableList.pop()\n\n  def getRandom(self):\n    ridx = randint(0, len(self.availableList)-1)\n    return self.availableList[ridx]\n\n\norg = OptGetRandom()\norg.insert(1)\norg.insert(2)\norg.insert(3)\norg.insert(4)\n\norg.getRandom()\n\nprint(org.availableList, org.cache)\norg.remove(3)\nprint(org.availableList, org.cache)\n\nprint([org.getRandom() for _ in range(5)])\n\n[1, 2, 3, 4] {1: 0, 2: 1, 3: 2, 4: 3}\n[1, 2, 4] {1: 0, 2: 1, 4: 2}\n[1, 4, 1, 1, 4]\n\n\n\nimport re\n\ndef replace_if_matches(text, substrings, replacement):\n    pattern = '|'.join(map(re.escape, substrings))\n    return re.sub(pattern, replacement, text)\n\ntext = \"The quick brown fox jumps over the lazy dog\"\nsubstrings = [\"quick\", \"fox\", \"lazy\"]\nreplacement = \"****\"\n\nresult = replace_if_matches(text, substrings, replacement)\nprint(result)\n\nThe **** brown **** jumps over the **** dog\n\n\n\ndef GetMinCostString(n, costMatrix):\n  if not n: return 0\n\n\n  def helper(c, idx):\n    ## base cases\n    if idx == n: return 0\n    if (c, idx) in memo: return memo[(c, idx)]\n\n    ## get the min price for current index\n    curCost = costMatrix[idx][c]\n    mcost = float(\"inf\")\n    for j in range(4):\n      if j != c:\n        mcost = min(mcost, helper(j, idx+1))\n\n    ## save in memo\n    memo[(c, idx)] = curCost + mcost\n    return memo[(c, idx)]\n\n  memo = {}\n  gmin = float(\"inf\")\n  for i in range(4):\n    gmin = min(gmin, helper(i, 0))\n\n  return gmin\n\ncmatrix = [\n    [2, 3, 4, 5],\n    [7, 3, 4, 1]\n]\nGetMinCostString(2, cmatrix)\n\n3\n\n\n\ndef CountPalindromes(l, r, s):\n  c, ans = 0, 0\n  while l &gt;= 0 and r &lt; len(s):\n    if s[l] != s[r]: break\n    l, r = l-1, r+1\n    ans += 1\n\n  return ans\n\ns = \"a\"\nfor i in range(len(s)):\n  o, e = CountPalindromes(i, i, s), CountPalindromes(i, i+1, s)\n  print(i, o, e)\n\n0 1 0\n\n\n\ndef MinOpsToSort(nums):\n  ans = 0\n  n = len(nums)\n  while not all([nums[i]==i+1 for i in range(n)]):\n    i = 0\n    while i &lt; n:\n      if nums[i] != i+1:\n        ans += 1\n        nums.append(nums.pop(i))\n        break\n      i += 1\n  return ans\n\nnums = [3, 2, 1]\nMinOpsToSort(nums)\n\n3\n\n\n\ndef FindMinInRotatedArray(nums):\n  l, r = 0, len(nums)-1\n  while l &lt;= r:\n    m = l + (r-l)//2\n    if nums[m] &gt; nums[r]:\n      l = m + 1\n    else:\n      r = m - 1\n  return l, r\n\nnums = [4, 5, 6, 7, 1, 2, 3]\nFindMinInRotatedArray(nums)\n\n(4, 3)\n\n\n\n\nclass TreeNode:\n\n  def __init__(self, v=None):\n    self.val = v\n    self.left = None\n    self.right = None\n\n\nclass BinaryTree:\n\n  def __init__(self, nlist):\n    self.root = self._create(nlist)\n\n  def _create(self, nlist):\n    pass\n\n\ndef CreateBinaryTree(nlist):\n  pass\n\n\ndef IsEqual(alist, blist):\n  aint, bint = \"\", \"\"\n  for i in alist:\n    aint += str(i)\n  for j in blist:\n    bint += str(j)\n\n  return int(aint) == int(bint)\n\n\nIsEqual([0, 1, 1, 0], [1, 1])\n\nFalse\n\n\n\nimport random\n\n\nrandom.uniform(0, 100)\n\n91.94578587615729\n\n\n\nimport random\nimport collections\n\nclass GetRandomWeightedValue:\n\n  def __init__(self, nums):\n    self.prefixSums = []\n    self.psum = 0\n    for v in nums:\n      self.psum += v\n      self.prefixSums.append(self.psum)\n\n  def GetRandomIndex(self):\n    t = random.uniform(0, self.psum)\n    for idx, p in enumerate(self.prefixSums):\n      if p &gt; t:\n        return nums[idx]\n\n\nnums = [1, 2, 3, 4, 5]\nwrnd = GetRandomWeightedValue(nums)\nans = []\nfor i in range(100):\n  ans.append(wrnd.GetRandomIndex())\n\nprint(collections.Counter(ans))\n\nCounter({5: 40, 4: 27, 3: 14, 2: 12, 1: 7})\n\n\n\ndef FindTheInterleaving(s1, s2, s3):\n  m, n , l = len(s1), len(s2), len(s3)\n  if m+n != l: return False\n\n  def helper(i, j, r):\n    if i==m and j==n:\n      return r == s3\n\n    if (i, j) in memo and memo[(i, j)]: return memo[(i, j)]\n\n    ans = False\n    if i&lt;m: ans = ans or helper(i+1, j, r+s1[i])\n    if j&lt;n: ans = ans or helper(i, j+1, r+s2[j])\n    memo[(i, j)] = ans\n    return ans\n\n  memo = {}\n  ans = helper(0, 0, \"\")\n  print(memo)\n  return ans\n\n\nFindTheInterleaving(\"abcdx\", \"efghy\", \"abefcdghxy\")\n\n\n{(5, 4): True, (5, 3): False, (5, 2): False, (5, 1): False, (5, 0): False, (4, 5): False, (4, 4): True, (4, 3): True, (4, 2): True, (4, 1): False, (4, 0): False, (3, 5): False, (3, 4): False, (3, 3): False, (3, 2): True, (3, 1): False, (3, 0): False, (2, 2): True, (2, 1): True, (2, 0): True, (1, 0): True, (0, 0): True}\n\n\nTrue\n\n\n\n{\n    'a' : 1,\n    'b' : 0,\n    'c' : 1,\n}\n\n\"abcac\"\n\nfrom collections import Counter\n\ndef ReorganizeString(s):\n\n\n  def helper(r, pc):\n    if len(r) == n:\n      ans.add(r)\n      return r, True\n\n    if (r, pc) in memo: return memo[(r, pc)]\n\n    res = \"\"\n    for c in counts.keys():\n      if c != pc and counts[c] &gt; 0:\n        counts[c] -= 1\n        res, f = helper(r+c, c)\n        if f:\n          memo[(res, c)] = res, True\n          return res, True\n        counts[c] += 1\n\n    return \"\", False\n\n  ans = set()\n  counts = Counter(s)\n  n = len(s)\n  memo = {}\n  seq, found = helper(\"\", \"\")\n  print(ans, seq)\n\n'''\neqpspvbpppwpgyppppe\n'''\nReorganizeString(\"eqpspvbpppwpgyppppe\")\n\n{'pepepqpspvpbpwpgpyp'} pepepqpspvpbpwpgpyp\n\n\n\n\nfrom collections import Counter, defaultdict\n\ndef FindMinWindowSubsting(sentence, substr):\n  if not sentence: return ''\n  subStrMap = Counter(substr)\n  l = r = 0\n\n  seenMap = defaultdict(int)\n  have, req = 0, len(subStrMap)\n  l = 0\n  res, resLen = [-1, -1], float(\"inf\")\n  for r, w in enumerate(sentence):\n    seenMap[w] += 1\n    if w in subStrMap and seenMap[w] == subStrMap[w]:\n      have += 1\n\n    while have == req:\n      if r-l+1 &lt; resLen:\n        res = [l, r]\n        resLen = min(resLen, r-l+1)\n\n      c = sentence[l]\n      seenMap[c] -= 1\n      if c in subStrMap and seenMap[c] &lt; subStrMap[c]:\n        have -= 1\n      l += 1\n\n  l, r = res[0], res[1]\n  return sentence[l:r+1] if resLen != float(\"inf\") else \"\"\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nFindMinWindowSubsting(s, t)\n\n\n'BANC'\n\n\n\ndef MaximumSubArraySum(nums):\n  n = len(nums)\n  maxsum, csum = float(\"-inf\"), 0\n  for n in nums:\n    csum = max(n, csum+n)\n    maxsum = max(maxsum, csum)\n\n  return maxsum\n\nnums = [-1,2,4,-3,5,2,-5,2]\nMaximumSubArraySum(nums)\n\n10\n\n\n\n## [0, n-1]\n\nfrom random import randint\nfrom collections import Counter\n\ndef CountingSort(nums):\n  mx = max(nums)\n  aux = [0 for _ in range(mx+1)]\n  for n in nums:\n    aux[n] += 1\n\n  sortedArray = []\n  for idx, ax in enumerate(aux):\n    if aux[idx] &gt; 0:\n      sortedArray.append(idx)\n\n  return sortedArray, Counter(nums)\n\nnums = [randint(0, 100) for _ in range(1000)]\nprint(nums[:20])\nslist, counts = CountingSort(nums)\nprint(slist[:20], \"\\n\")\nfe = []\nfor k, v in counts.items():\n  if v&gt;10: fe.append(k)\nprint(fe)\n\n[90, 24, 92, 76, 99, 83, 94, 53, 14, 24, 52, 78, 8, 48, 28, 40, 16, 1, 23, 86]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] \n\n[92, 94, 53, 52, 78, 8, 28, 40, 16, 1, 23, 60, 77, 66, 37, 6, 97, 50, 72, 31, 44, 15, 22, 41, 11, 85, 64, 43, 38, 100, 75, 55, 57, 51, 88, 59, 9, 49, 69, 81, 5, 62, 45]\n\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n\ndef getCollatzPoints(n):\n  xlist, ylist = [], []\n  while n != 1:\n    x, y = n, n//2 if n%2==0 else n*3+1\n    xlist.append(x)\n    ylist.append(y)\n    n = y\n  return xlist, ylist\n\ndef CollatzConjecture(l, r):\n  for i in range(l, r+1):\n    x, y = getCollatzPoints(i)\n    plot(x, y, [j-i for i, j in zip(x, y)], True)\n\ndef plot(xlist, ylist, dlist,  diff=False):\n\n  if diff:\n    plt.title(\"diff {0}\".format(xlist[0]))\n    plt.plot(dlist)\n    plt.show()\n    return\n\n  # Create the plot (using the default scatter plot style)\n  sns.scatterplot(x=xlist, y=ylist)\n\n  # Customize the plot (optional)\n  plt.xlabel(\"X-axis\")\n  plt.ylabel(\"Y-axis\")\n  plt.title(\"Discrete Data Plot\")\n\n  # Show the plot\n  plt.show()\n\nCollatzConjecture(4000, 4005)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef GenerateSubset(n):\n\n  def helper(k):\n    if k==n+1:\n      slist.append(subset.copy())\n      return\n    subset.append(k)\n    helper(k+1)\n    subset.pop()\n    helper(k+1)\n\n\n  slist, subset = [], []\n  helper(1)\n  return sorted(slist, key=lambda x: len(x))\n\nGenerateSubset(5)\n\n[[],\n [1],\n [2],\n [3],\n [4],\n [5],\n [1, 2],\n [1, 3],\n [1, 4],\n [1, 5],\n [2, 3],\n [2, 4],\n [2, 5],\n [3, 4],\n [3, 5],\n [4, 5],\n [1, 2, 3],\n [1, 2, 4],\n [1, 2, 5],\n [1, 3, 4],\n [1, 3, 5],\n [1, 4, 5],\n [2, 3, 4],\n [2, 3, 5],\n [2, 4, 5],\n [3, 4, 5],\n [1, 2, 3, 4],\n [1, 2, 3, 5],\n [1, 2, 4, 5],\n [1, 3, 4, 5],\n [2, 3, 4, 5],\n [1, 2, 3, 4, 5]]\n\n\n\nclass UnionFind:\n\n  def __init__(self, n):\n    self.parent = [i for i in range(n)]\n    self.size = [1] * n\n\n  def find(self, val):\n    if self.parent[val] != val:\n      self.parent[val] = self.find(self.parent[val])\n    return self.parent[val]\n\n  def union(self, x, y):\n    xp, yp = self.find(x), self.find(y)\n    if xp != yp:\n      if self.size[xp] &lt; self.size[yp]:\n        self.parent[xp] = yp\n        self.size[yp] += self.size[xp]\n      else:\n        self.parent[yp] = xp\n        self.size[yp] += self.size[xp]\n\n\nu = UnionFind(10)\nu.union(1, 2)\nu.union(2, 3)\n\nu.union(4, 5)\nu.union(5, 4)\n\nprint(u.find(3))\nprint(u.find(5))\n\n1\n4\n\n\n\ndef TargetSum(nums, t):\n  cache = {}\n  for idx, n in enumerate(nums):\n    if t-n in cache:\n      return [cache[t-n], idx]\n    cache[n] = idx\n  return [-1, -1]\n\n\nTargetSum([2,7,11,15], 9)\n\n[0, 1]\n\n\n\ndef FindMaxSpeacialSubstring(s):\n  pass\n\n\n\ndef IsPlaindromeString(s):\n\n  def helper(l, r):\n    if l &lt; 0 or r &gt;= len(s): return False\n    while l&lt;= r:\n      if s[r] != s[l]: return False\n      l, r = l+1, r-1\n    return True\n\n  return helper(0, len(s)-1)\n\nIsPlaindromeString(\"as\")\n\nFalse\n\n\n\nfrom collections import Counter\n\ndef OddCounts(nums):\n  tval = 0\n  for n in nums:\n    tval += n & 1\n    print(tval)\n\nprint(\"even & 1: \", 2&1)\nOddCounts([1, 0, 3, 2, 4, 6, 9])\n\neven & 1:  0\n1\n1\n2\n2\n2\n2\n3\n\n\n\ndef IsPossibleCombination(word, wlist):\n\n  def helper(start):\n    if start &gt;= wlen:\n      return True\n\n    for cend in range(start, wlen+1):\n      cw = word[start:cend+1]\n      print(\"cword: \", cw)\n      if cw in wordSet:\n        if helper(cend+1):\n          print(\"--&gt; found: \", cw)\n          return True\n\n    return False\n\n  wlen = len(word)\n  wordSet = set(wlist)\n  return helper(0)\n\n\n# wlist = [\"wal\", \"marty\", \"test\", \"wa\", \"mar\", \"t\"]\n# IsPossibleCombination(\"walmart\", wlist)\n\n\nwlist = [\"a\", \"b\", \"c\", \"d\", \"mar\", \"t\"]\nIsPossibleCombination(\"abcd\", wlist)\n\n\ncword:  a\ncword:  b\ncword:  c\ncword:  d\n--&gt; found:  d\n--&gt; found:  c\n--&gt; found:  b\n--&gt; found:  a\n\n\nTrue\n\n\n\nclass Node:\n\n  def __init__(self, k=None, v=None):\n    self.key = k\n    self.value = v\n    self.prev = None\n    self.next = None\n\n\nclass LRUCache:\n\n  def __init__(self, capacity):\n    self.capacity = capacity\n    self.store = {}\n    self.left, self.right = Node(), Node()\n    self.left.next = self.right\n    self.right.prev = self.left\n\n  def PrintStore(self):\n    for k, v in self.store.items():\n      print(\"key: \", k, \", value: \", v.value)\n\n\n  def __remove(self, node):\n    prevNode, nextNode = node.prev, node.next\n    prevNode.next, nextNode.prev = nextNode, prevNode\n\n\n  def __insert(self, node):\n    prevNode, nextNode = self.right.prev, self.right\n    node.next, node.prev = nextNode, prevNode\n    prevNode.next = nextNode.prev = node\n\n  def Get(self, key):\n    if key not in self.store: return -1\n    vnode = self.store.get(key, None)\n    self.__remove(vnode)\n    self.__insert(vnode)\n    return vnode.value\n\n  def Put(self, k, v):\n    ## if key is already there remove it\n    if k in self.store:\n      node = self.store[k]\n      self.__remove(node)\n\n    self.store[k] = Node(k, v)\n    self.__insert(self.store[k])\n\n    ## if capacity is full evict the lru node\n    if len(self.store) &gt; self.capacity:\n      enode = self.left.next\n      self.__remove(enode)\n      del self.store[enode]\n\n\nlru = LRUCache(10)\nlru.Get(10)\nlru.Put(1, 1)\nlru.Put(2, 2)\nlru.Put(3, 3)\nlru.Put(1, 4)\nlru.PrintStore()\n\nkey:  1 , value:  4\nkey:  2 , value:  2\nkey:  3 , value:  3\n\n\n\nfrom collections import defaultdict, namedtuple\nimport heapq\n\nclass PageData:\n\n  def __init__(self, pName, freq=0):\n    self.pageName = pName\n    self.frequency = freq\n\n\ndef FindTopKPages(plist):\n\n  pageCounts = defaultdict(int)\n  for pname in plist:\n\n    pageCounts[pname] += 1\n\n  cmp = lambda x: x.Frequency\n\n  pageHeap = []\n  pageData = namedtuple('PageData', ['Freq', \"PageName\"])\n  for p, c in pageCounts.items():\n    heapq.heappush(pageHeap, pageData(c, p))\n\n  return [heapq.heappop(pageHeap) for _ in range(len(pageHeap))]\n\n\nFindTopKPages([1, 1, 1, 2, 3, 1, 2, 1, 3])\n\n[PageData(Freq=2, PageName=2),\n PageData(Freq=2, PageName=3),\n PageData(Freq=5, PageName=1)]\n\n\n\nimport time\nimport random\n\nclass UniqueIDGenerator:\n\n  @staticmethod\n  def generate():\n    tstamp = int(time.time()).to_bytes(5, 'big')\n    randbytes = random.randbytes(5).to_bytes(5, 'big')\n\n\n\n\nimport hashlib\n\ndef generate_md5_hash(text):\n  \"\"\"Generates the MD5 hash for the given text.\"\"\"\n  encoded_text = text.encode('utf-8')  # Encode text into bytes\n  hash_object = hashlib.md5(encoded_text)\n  hex_digest = hash_object.hexdigest()\n  return hex_digest\n\n# Example usage\ntext = \"This is some text to hash.\"\nmd5_hash = generate_md5_hash(text)\nprint(f\"MD5 hash: {md5_hash}\")\n\nMD5 hash: 33624593eaec673d0eb624c410663976\n\n\n\nfrom collections import namedtuple\n\ndef ShowData(data):\n  i1, i2 = data.item1, data.item2\n  p = f'{i1}-{i2}'\n  print(p)\n\ndata = namedtuple('Data', ['item1', 'item2'])\ndata.item1 = \"iPhone\"\ndata.item2 = \"Samsung\"\nShowData(data)\n\niPhone-Samsung\n\n\n\ndef FindTwoMinValues(nums):\n  m1 = m2 = float(\"inf\")\n  m1 = min(nums)\n  for n in nums:\n    if n &gt; m1 and n &lt; m2:\n      m2 = n\n\n  return m1, m2\n\nnums = [1, -2, 3, 4, 5, 6, 7, 8]\nFindTwoMinValues(nums)\n\n(-2, 1)\n\n\n\nclass Graph:\n\n  def __init__(self, vcount=0):\n    self.vertices = vcount\n    self.edgeList = []\n\n  def addEdge(self, s, d, w):\n    self.edgeList.append([s, d, w])\n\n  def bellmanFord(self, src):\n    dist = [float(\"inf\") for _ in range(self.vertices)]\n    dist[0] = src\n\n    for _ in range(self.vertices-1):\n      for s, d, w in self.edgeList:\n        if dist[s] != float(\"inf\") and dist[s] + w  &lt; dist[d]:\n          dist[d] = dist[s] + w\n\n    for s, d, w in self.edgeList:\n      if dist[s] != float(\"inf\") and dist[s] + w  &lt; dist[d]:\n        return {'failed' : 'cycle dectected in graph'}\n\n    return { i: dist[i] for i in range(self.vertices) }\n\n\ng = Graph(5)\ng.addEdge(0, 1, 5)\ng.addEdge(0, 2, 4)\ng.addEdge(1, 3, 3)\ng.addEdge(2, 1, 6)\ng.addEdge(3, 2, 2)\n\ng.bellmanFord(0)\n\n{0: 0, 1: 5, 2: 4, 3: 8, 4: inf}\n\n\n\nclass Node():\n\n  def __init__(self, val):\n    self.val = val\n    self.left = Node\n    self.right = Node\n\ndef FindPath(node):\n\n  def dfs(node):\n    pass\n\n\nn = Node(5)\nprint(n.val)\n\n5\n\n\n\nimport datetime\n\ndef DateTime(y, m, d):\n  day = [\"Monday\", \"Tue\", \"Wed\", \"Thur\", \"Fri\", \"Sat\", \"Sunday\"]\n  d = datetime.date(y, m, d)\n  return day[d.weekday()]\n\n\n## day = 18, month = 7, year = 1999\nDateTime(1999, 7, 18)\n\n'Sunday'\n\n\n\nfrom collections import deque\n\ndef FindTheShortestPath(matrix):\n\n  def getNeigh(r, c):\n    dirs = {\n        (0, 1), (0, -1), (1, 0), (-1, 0),\n        (1, 1), (1, -1), (-1, 1), (-1, -1)\n    }\n    for dr, dc in dirs:\n      nr, nc = r+dr, c+dc\n      if 0 &lt;= nr &lt; ROWS and 0 &lt;= nc &lt; COLS and matrix[nr][nc] == 0:\n        yield nr, nc\n\n  ROWS, COLS = len(matrix), len(matrix[0])\n  queue = deque([(0, 0, 1)])\n  visited = set()\n  visited.add((0, 0))\n\n  while queue:\n    r, c, dist = queue.popleft()\n    if r == ROWS-1 and c == COLS-1:\n      return dist\n    for nr, nc in getNeigh(r, c):\n      if (nr, nc) not in visited:\n        visited.add((nr, nc))\n        queue.append((nr, nc, dist+1))\n\n  return -1\n\nmatrix = [[1,0,0],[1,1,0],[1,1,0]]\nmatrix2 = [[0,1],[1,0]]\nFindTheShortestPath(matrix2)\n\n2\n\n\n\n'''\n# Parking in vehicle inspection centers: DMV has vehicle inspection centers to inspect the quality of all new vehicles. You are charged to manage the vehicles coming in to inspection centers.\n\nIt is required keep as much distance as possible between the new vehicle and its neighbors.\n\nYou can assume that the parking lot is a straight line of individual parking spaces each numbered from 0 to N-1. As each vehicle comes in you want to assign it a parking spot. Let’s say you assigned parking space 0 to the very first car now to maximize the distance you’d assign the next car to space N-1. The next car now could be in the space N/2.\n\nYour problem now is to figure out the position at which the next incoming car should park. You can assume that the parking lot was empty when you started.\n\n\nInput:\nN = 20\n\nc1: 1\nc2: N-1\nc3: 1, 10, 20\nc4: 1, 10, 15, 20\n\nl   |  r\n1      20\n1. 5  10. 15 20\n1__6__4____3____5____2\n\n1_______3_______2\n\nheap : , (10, 20), (1, 5), (5, 10)\n0-N//2  N//2 - N\n\n\n'''\n\nimport heapq\n\n\nclass ParkingLot:\n\n    def __init__(self, N) -&gt; None:\n        self.carCounts = 0\n        self.slots = N\n        self.positions = [0] * N\n        self.currentSlotSize = N\n        self.maxDisHeap = []\n        # heapq.heappush(self.maxDisHeap, (0, self.slots-1))\n\n\n    def display(self):\n      print(\"car \", self.carCounts, self.positions)\n\n\n    def AddCarToParking(self):\n        if self.carCounts == 0:\n            self.carCounts += 1\n            self.positions[0] = self.carCounts\n            return\n\n\n        if self.carCounts == 1:\n            self.carCounts += 1\n            self.positions[self.slots-1] = self.carCounts\n            maxDis = self.slots-1 // 2\n            heapq.heappush(self.maxDisHeap, (-maxDis, (0, self.slots-1)))\n            return\n\n\n        if self.maxDisHeap:\n            _, pos = heapq.heappop(self.maxDisHeap)\n            self.carCounts += 1\n            mid = (pos[1] + pos[0]) // 2\n            self.positions[mid] = self.carCounts\n\n            ## push the two new slot\n            p1 = (pos[0], mid)\n            p2 = (mid, pos[1])\n            heapq.heappush(self.maxDisHeap, (-mid, p1 ))\n            heapq.heappush(self.maxDisHeap, (-mid, p2 ))\n\n\n\np = ParkingLot(20)\np.AddCarToParking()\np.display()\n\n\np.AddCarToParking()\np.display()\n\np.AddCarToParking()\np.display()\n\np.AddCarToParking()\np.display()\n\np.AddCarToParking()\np.display()\n\n\np.AddCarToParking()\np.display()\n\ncar  1 [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ncar  2 [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2]\ncar  3 [1, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2]\ncar  4 [1, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2]\ncar  5 [1, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0, 0, 0, 2]\ncar  6 [1, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 6, 0, 0, 5, 0, 0, 0, 0, 2]\n\n\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnums[-5:]\n\n[6, 7, 8, 9, 10]\n\n\n\nimport heapq\n\nnums = [11, 92, 33, 4, 55, 6, 7, 8, 9, 10]\nheapq.heapify(nums)\nprint(nums)\n\n[4, 8, 6, 9, 10, 33, 7, 92, 11, 55]\n\n\n\n'''\n  It is not possible to transpose the matrix in place if the size\n  is not square.\n\n\n\n'''\n\ndef TransposeGenerix(matrix):\n  '''\n    Basic idea is to swap the col with row\n  '''\n  ROWS = len(matrix)\n  COLS = len(matrix[0])\n  newMatrix = [[0 for _ in range(ROWS)] for _ in range(COLS)]\n  for i in range(ROWS):\n    for j in range(COLS):\n      newMatrix[j][i] = matrix[i][j]\n\n  return newMatrix\n\n\ndef Transpose(matrix):\n  ROWS = len(matrix)\n  COLS = len(matrix[0])\n  for i in range(ROWS):\n    for j in range(i+1, COLS):\n      matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i]\n\n\ndef RevertMatrix(matrix):\n  ROWS = len(matrix)\n  COLS = len(matrix[0])\n  for i in range(ROWS):\n    for j in range(COLS//2):\n      matrix[i][j], matrix[i][COLS-1-j] = matrix[i][COLS-1-j], matrix[i][j]\n\n\ndef printMatrix(matrix):\n  for row in matrix:\n    print(row)\n  print()\n\n# matrix = [\n#     [1,2,3],\n#     [4,5,6],\n#     [7,8,9],\n#     [10, 11, 12]\n# ]\n\nmatrix2 = [\n    [1, 2, 3],\n    [4, 5, 6]\n]\n\nprintMatrix(matrix2)\nnewM = TransposeGenerix(matrix2)\nprintMatrix(newM)\nRevertMatrix(newM)\nprintMatrix(newM)\n\n[1, 2, 3]\n[4, 5, 6]\n\n[1, 4]\n[2, 5]\n[3, 6]\n\n[4, 1]\n[5, 2]\n[6, 3]\n\n\n\n\ndef GetCode(l):\n  return ord(l) - ord('A') + 1\n\nfor i in range(26):\n  v = ord('A') + i\n  print(GetCode(chr(v)))\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\nimport heapq\n\nclass ParkingLot:\n    def __init__(self, N):\n        self.N = N\n        self.heap = []\n        # Initial segment from 0 to N-1\n        heapq.heappush(self.heap, (-N, 0, N-1)) # Using negative distance for max heap\n\n    def park(self):\n        if not self.heap:\n            raise Exception(\"No more spaces available\")\n\n        # Get the largest segment\n        dist, start, end = heapq.heappop(self.heap)\n        dist = -dist\n\n        # Choose the middle point\n        if start == end:\n            pos = start\n        else:\n            pos = (start + end) // 2\n\n        # Create new segments\n        if pos &gt; start:\n            heapq.heappush(self.heap, (-(pos - start), start, pos - 1))\n        if pos &lt; end:\n            heapq.heappush(self.heap, (-(end - pos), pos + 1, end))\n\n        return pos\n\n# Example usage:\nN = 20  # Size of the parking lot\nparking_lot = ParkingLot(N)\n\n# Simulate parking cars\nfor _ in range(N):\n    print(parking_lot.park())\n\n9\n14\n4\n17\n1\n6\n11\n2\n7\n12\n15\n18\n0\n3\n5\n8\n10\n13\n16\n19\n\n\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnums[1:-1]\n\n[2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nfrom typing import List\n\nclass Solution:\n    def maxOperations(self, nums: List[int]) -&gt; int:\n\n        if len(nums) &lt; 2: return 0\n        cache = {}\n        def helper(score, s=0, e=len(nums)-1):\n            if e &lt;= s: return 0\n\n            if (s, e) in cache: return cache[(s, e)]\n\n            m1 = 1 + helper(score, s+2, e) if score == sum(nums[s:s+2]) else 0\n            m2 = 1 + helper(score, s, e-2) if score == sum(nums[e-1:e+1]) else 0\n            m3 = 1 + helper(score, s+1, e-1) if score == nums[s] + nums[e] else 0\n\n            cache[(s, e)] = max(m1, m2, m3)\n            return cache[(s, e)]\n\n        s1 = helper(sum(nums[:2]))\n        s2 = helper(sum(nums[-2:]))\n        s3 = helper(nums[0] + nums[1])\n\n        return max(\n            s1, s3, s2\n        )\n\ns = Solution()\ns.maxOperations([1,2,3,4,5,6,7,8,9,10])\n\n1\n\n\n\ndef GetGCD(a, b):\n  a, b = min(a, b), max(a, b)\n  while b:\n    a, b = b, a%b\n  return a\n\ndef GetLCM(a, b):\n  return (a*b) // GetGCD(a, b)\n\nGetLCM(4, 6)\n\n12\n\n\n\nclass TrieNode():\n\n  def __init__(self):\n    self.children = {}\n    self.isWord = False\n\nclass Trie():\n\n  def __init__(self):\n    self.root = TrieNode()\n\n  def Insert(self, word):\n    '''\n      inserts the word in the Trie\n    '''\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        node.children[c] = TrieNode()\n      node= node.children[c]\n    node.isWord = True\n\n  def Search(self, word):\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        return False\n      node = node.children[c]\n    return node.isWord == True\n\n  def StartsWith(self, prefix):\n    node = self.root\n    words = []\n\n    for c in prefix:\n      if c not in node.children:\n        return words\n      node = node.children[c]\n\n    def collectAllWords(tnode, cword):\n      if tnode.isWord:\n        words.append(cword)\n      for c, cnode in tnode.children.items():\n         collectAllWords(cnode, cword + c)\n      return\n\n    collectAllWords(node, prefix)\n    return words\n\n\ntrie = Trie()\ntrie.Insert(\"app\")\ntrie.Insert(\"apple\")\ntrie.Insert(\"apps\")\ntrie.Insert(\"appdata\")\ntrie.Insert(\"nextappdata\")\nprint(trie.Search(\"app\"))\nprint(trie.StartsWith(\"app\"))\n\n\nTrue\n['app', 'apple', 'apps', 'appdata']\n\n\n\ndef FindMinOps(nums, x):\n\n  def helper(cnum, l, r):\n    if cnum==0:\n      return 0\n\n    if cnum &lt; 0: return 0\n\n     ## choose left and explore\n    lval, lops = nums[l], float(\"inf\")\n    if lval &lt;= cnum and l &lt;= r:\n      lops = helper(cnum-lval, l+1, r)\n\n    ## choose right to explore\n    rval, rops = nums[r], float(\"inf\")\n    if rval &lt;= cnum and l &lt;= r:\n      rops = helper(cnum-rval, l, r-1)\n\n    return min(lops, rops) + 1\n\n  return helper(x, 0, len(nums)-1)\n\nFindMinOps([1, 1, 4, 2, 3], 5)\nFindMinOps([5, 4, 3, 2, 1], 15)\n\n## ([3, 2, 20, 1, 1, 3], 10)\nFindMinOps([3, 2, 20, 1, 1, 3], 10)\n\n5\n\n\n\n'''\nFirst scenario:\n    1. Get the whole list from each server\n    2. O(N), n = total_nums\n    3. Heap: O(N log k), k = no. of servers\n\nSecond Scenario: Not enough memory\n    Ouput: store it in other server disk\n    1.\n\n'''\n\nimport heapq\n\nclass Server():\n\n    def __init__(self, listOfNums):\n        self.data = {}\n        for i, nums in enumerate(listOfNums):\n            self.data[i] = nums\n        self.size = len(listOfNums)\n\n    def GetServerData(self, sname):\n        return self.data.get(sname, [])\n\n    def GetServerList(self):\n        return self.size\n\n\nclass ExternalSort():\n\n    def __init__(self, sutil):\n        self.finalList = []\n        self.heapData = []\n        self.serverUtil = sutil\n\n\n    def GetSortedData(self):\n        serverList = self.serverUtil.GetServerList()\n        serverData = []\n        for i in range(serverList):\n          d = self.serverUtil.GetServerData(i)\n          serverData.append(\n              iter(d)\n          )\n\n        for s, n in enumerate(serverData):\n          heapq.heappush(self.heapData, (next(n), s))\n\n        while self.heapData:\n          n, sId = heapq.heappop(self.heapData)\n          self.finalList.append(n)\n          d = next(serverData[sId], None)\n          if d != None:\n            heapq.heappush(self.heapData, (d, sId))\n\n        return self.finalList\n\ns = Server(\n    [[1, 2, 3, 4],[3, 5, 6, 7],[5, 7, 8, 10]]\n)\n\ns2 = Server(\n    [[1, 12, 13, 14],[3],[2, 2, 2, 2]]\n)\n\nes = ExternalSort(s2)\nprint(es.GetSortedData())\n\n[1, 2, 2, 2, 2, 3, 12, 13, 14]\n\n\n\ndef MinOps(nums, x):\n\n  def helper(ctotal, l, r):\n    if ctotal == 0:\n      return 0\n    if ctotal &lt; 0:\n      return float(\"inf\")\n\n    ## choose left and explore\n    lval, lops = nums[l], float(\"inf\")\n    if l &lt;= r and lval &lt;= ctotal:\n      lops = 1 + helper(ctotal-lval, l+1, r)\n\n    ## choose right and explore\n    rval, rops = nums[r], float(\"inf\")\n    if l &lt;= r and rval &lt;= ctotal:\n      rops = 1 + helper(ctotal-rval, l, r-1)\n\n    return min(lops, rops)\n\n  return helper(x, 0, len(nums)-1)\n\na1 = MinOps([3, 2, 20, 1, 1, 3], 10)\nprint(a1)\n\n5\n\n\n\n'''\n\n  There are two ops :\n  1. Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).\n  2. Paste: You can paste the characters which are copied last time. This is basically (copy+paste)\n\n  options:\n  &gt;\n\n'''\n\ndef FindMinKeyOps(n):\n  memo = {}\n\n  def helper(slen, clen):\n    '''\n      slen: len of the current the string\n      clen: len of the copy string in the clipboard\n    '''\n\n    if slen == n: return 1\n    if slen &gt; n: return float(\"inf\")\n\n    if (slen, clen) in memo: return memo[(slen,clen)]\n\n    copyPaste = float(\"inf\")\n    if slen != clen:\n      copyPaste = 2 + helper(slen*2, slen)\n\n    ## only paste\n    paste = 1 + helper(slen+clen, clen)\n\n    minOps = min(\n        copyPaste,\n        paste\n    )\n    memo[(slen, clen)] = minOps\n    return memo[(slen, clen)]\n\n  if n == 1 : return 0\n  return helper(1, 1)\n\n\n# for i in range(0, 500, 25):\n#   print(FindMinKeyOps(i+3))\n\nFindMinKeyOps(200)\n\n16\n\n\n\ndef FindMinRepeats(a, b):\n  s1, s2 = len(a), len(b)\n  if s2 &lt; s1: return -1\n\n\n\n\nimport heapq\n\ndef MergeSortedArrays(alist):\n  minheap = []\n  sortedArrays = [ iter(i) for i in alist if i != None]\n  finalSortedList = []\n\n  ## init the heap with the first element from each list\n  for ilist in sortedArrays:\n    d = next(ilist, None)\n    heapq.heappush(minheap, (d, ilist))\n\n  ## pop and insert the next in the line from each list\n  while minheap:\n    n, clist = heapq.heappop(minheap)\n    finalSortedList.append(n)\n    nextData = next(clist, None)\n    if nextData:\n      heapq.heappush(minheap, (nextData, clist))\n\n  return finalSortedList\n\ns1 = [\n    [1, 2, 3, 4, 5],\n    [12, 13, 14, 15, 16],\n    [90, 91, 92]\n]\nMergeSortedArrays(s1)\n\n[1, 2, 3, 4, 5, 12, 13, 14, 15, 16, 90, 91, 92]\n\n\n\nd = [\n    [1, 2, 3, 4],\n    [],\n    [23, 34]\n]\nd = [ iter(i) for i in d if i != []]\nfor i in d:\n  s = next(i)\n  print(s)\n\n1\n23\n\n\n\ndef FindLongestIncreasingSeq(nums):\n\n  N = len(nums)-1\n  def helper(cidx, tlen):\n    if cidx == N:\n      return tlen\n\n    clen = 0\n    for idx in range(cidx+1, N):\n      if nums[idx] &gt; nums[cidx]:\n        clen = max(clen, helper(idx+1, tlen+1))\n    return clen\n\n\n  return helper(0, 1)\n\n\nnums = [4, 5, 6, 7]\nFindLongestIncreasingSeq(nums)\n\n\n\n\n2\n\n\n\nimport threading\nimport time\n\n\nclass ThreadSafeMap():\n\n  def __init__(self):\n    self.dataMap = {}\n    self.lock = threading.Lock()\n\n  def set(self, k=None, v=None):\n    print(\"adding {0} and {1}\".format(k, v))\n    with self.lock:\n      self.dataMap[k] = v\n\n  def get(self, k):\n    with self.lock:\n      return self.dataMap.get(k, None)\n\n  def remove(self, k):\n    with self.lock:\n      if k in self.dataMap:\n        del self.dataMap[k]\n\n\ndef TestThreadSafeMap(count):\n  tmap = ThreadSafeMap()\n\n  def writeData(count):\n    for c in range(count):\n      time.sleep(1)\n      tmap.set(c, c)\n\n  def readData(count):\n    for c in range(count):\n      time.sleep(1)\n      d = tmap.get(c)\n      print(\"key : {0}, data: {1}\".format(c, d))\n\n  t1 = threading.Thread(target=writeData, args=[count])\n  t2 = threading.Thread(target=readData, args=[count])\n\n  t1.start()\n  t2.start()\n\n  t1.join()\n  t2.join()\n\nTestThreadSafeMap(5)\n\n\n\nadding 0 and 0\nkey : 0, data: 0\nadding 1 and 1\nkey : 1, data: 1\nadding 2 and 2key : 2, data: None\n\nadding 3 and 3\nkey : 3, data: 3\nadding 4 and 4key : 4, data: None\n\n\n\n\nfrom collections import deque\n\nclass ParkingLot():\n\n  def __init__(self, size=10):\n    self.slots = size\n    self.parkinglot = [\"-\" for i in range(size)]\n    self.queue = deque()\n    self.queue.append((0, 0))\n    self.queue.append((size-1, size-1))\n    self.queue.append((1, size-2))\n\n\n  def GetNextSlot(self):\n    '''\n      return next slot to be used for parking\n    '''\n    if not self.queue:\n      return \"error : no more slots available\"\n\n    l, r = self.queue.popleft()\n    if l == r:\n      self.parkinglot[l] = \"P\"\n      return l\n\n    m = l + (r-l)//2\n\n    ## handle two consecutive slots\n    if abs(r-l) == 1:\n      self.queue.append((r, r))\n      self.parkinglot[l] = \"P\"\n      return l\n\n    if abs(r-l) == 2:\n      self.queue.append((l, l))\n      self.queue.append((r, r))\n      self.parkinglot[m] = \"P\"\n      return m\n\n    if abs(r-l) == 3:\n      self.queue.append((l, l))\n      self.queue.append((m+1, r))\n      self.parkinglot[m] = \"P\"\n      return m\n\n\n    firstHalf, secondHalf = (l, m-1), (m+1, r)\n    self.queue.append(firstHalf)\n    self.queue.append(secondHalf)\n    self.parkinglot[m] = \"P\"\n    return m\n\n\n\npsize = 20\np = ParkingLot(psize)\nfor i in range(psize):\n  print(\"parking at slot : \", p.GetNextSlot())\n  print(p.parkinglot)\n  print()\n\nparking at slot :  0\n['P', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-']\n\nparking at slot :  19\n['P', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', 'P']\n\nparking at slot :  9\n['P', '-', '-', '-', '-', '-', '-', '-', '-', 'P', '-', '-', '-', '-', '-', '-', '-', '-', '-', 'P']\n\nparking at slot :  4\n['P', '-', '-', '-', 'P', '-', '-', '-', '-', 'P', '-', '-', '-', '-', '-', '-', '-', '-', '-', 'P']\n\nparking at slot :  14\n['P', '-', '-', '-', 'P', '-', '-', '-', '-', 'P', '-', '-', '-', '-', 'P', '-', '-', '-', '-', 'P']\n\nparking at slot :  2\n['P', '-', 'P', '-', 'P', '-', '-', '-', '-', 'P', '-', '-', '-', '-', 'P', '-', '-', '-', '-', 'P']\n\nparking at slot :  6\n['P', '-', 'P', '-', 'P', '-', 'P', '-', '-', 'P', '-', '-', '-', '-', 'P', '-', '-', '-', '-', 'P']\n\nparking at slot :  11\n['P', '-', 'P', '-', 'P', '-', 'P', '-', '-', 'P', '-', 'P', '-', '-', 'P', '-', '-', '-', '-', 'P']\n\nparking at slot :  16\n['P', '-', 'P', '-', 'P', '-', 'P', '-', '-', 'P', '-', 'P', '-', '-', 'P', '-', 'P', '-', '-', 'P']\n\nparking at slot :  1\n['P', 'P', 'P', '-', 'P', '-', 'P', '-', '-', 'P', '-', 'P', '-', '-', 'P', '-', 'P', '-', '-', 'P']\n\nparking at slot :  3\n['P', 'P', 'P', 'P', 'P', '-', 'P', '-', '-', 'P', '-', 'P', '-', '-', 'P', '-', 'P', '-', '-', 'P']\n\nparking at slot :  5\n['P', 'P', 'P', 'P', 'P', 'P', 'P', '-', '-', 'P', '-', 'P', '-', '-', 'P', '-', 'P', '-', '-', 'P']\n\nparking at slot :  7\n['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', '-', 'P', '-', 'P', '-', '-', 'P', '-', 'P', '-', '-', 'P']\n\nparking at slot :  10\n['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', '-', 'P', 'P', 'P', '-', '-', 'P', '-', 'P', '-', '-', 'P']\n\nparking at slot :  12\n['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', '-', 'P', 'P', 'P', 'P', '-', 'P', '-', 'P', '-', '-', 'P']\n\nparking at slot :  15\n['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', '-', 'P', 'P', 'P', 'P', '-', 'P', 'P', 'P', '-', '-', 'P']\n\nparking at slot :  17\n['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', '-', 'P', 'P', 'P', 'P', '-', 'P', 'P', 'P', 'P', '-', 'P']\n\nparking at slot :  8\n['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', '-', 'P', 'P', 'P', 'P', '-', 'P']\n\nparking at slot :  13\n['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', '-', 'P']\n\nparking at slot :  18\n['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P']\n\n\n\n\nw = [\"word?\", \"apple!\", \"word?\"]\np = [\"?\", \"!\"]\n\n\n\nimport math\ndef FindPrimesInRange(n):\n\n  primes = [False, False] + [True] * (n-2)\n  nsqrt = int(math.sqrt(n) + 1)\n\n  for num in range(2, nsqrt):\n    if primes[num]:\n      for mul in range(num*num, n, num):\n        primes[mul] = False\n\n  return [i for i, v in enumerate(primes) if v]\n\nFindPrimesInRange(10)\n\n[2, 3, 5, 7]\n\n\n\ndef FindSqrt(n):\n\n  def helper(t):\n    l, h = 0, t\n    while l &lt;= h:\n      m = l + (h-l)//2\n      if m*m==t: return m\n      elif m*m &gt; t:\n        h = m - 1\n      else:\n        l = m + 1\n    return h\n\n  return helper(n)\n\nfor i in range(8, 22):\n  print(\"i : \", FindSqrt(i), math.sqrt(i))\n\n\n\ni :  2 2.8284271247461903\ni :  3 3.0\ni :  3 3.1622776601683795\ni :  3 3.3166247903554\ni :  3 3.4641016151377544\ni :  3 3.605551275463989\ni :  3 3.7416573867739413\ni :  3 3.872983346207417\ni :  4 4.0\ni :  4 4.123105625617661\ni :  4 4.242640687119285\ni :  4 4.358898943540674\ni :  4 4.47213595499958\ni :  4 4.58257569495584\n\n\n\nimport heapq\n\nclass OnlineMedian():\n\n  def __init__(self):\n    self.left = [] ## maxHeap\n    self.right = [] ## minHeap\n\n  def Add(self, num):\n    heapq.heappush(self.left, -1 * num)\n    heapq.heappush(self.right, -1 * heapq.heappop(self.left))\n\n    if len(self.right) &gt; len(self.left):\n      heapq.heappush(self.left, -1 * heapq.heappop(self.right))\n\n  def GetMedian(self):\n    return -1 * self.left[0] if len(self.left) &gt; len(self.right) else (self.right[0] - self.left[0])/2\n\nom = OnlineMedian()\nom.Add(1)\nom.Add(2)\nom.Add(3)\nom.Add(3)\nom.Add(3.5)\nom.Add(3.6)\nom.Add(13)\nom.Add(13)\nprint(om.GetMedian())\n\n3.25\n\n\n\ndef FindMissingRange(nums):\n  res = []\n\n  if not nums: return \"(1...1000)\"\n\n  start, end = 0, 1000\n  res = []\n  N = len(nums)\n\n  if start &lt; nums[0]:\n    res.append([start, nums[0]-1])\n\n  for i in range(N-1):\n    if nums[i+1] - nums[i] &lt;= 1:\n      continue\n    res.append([nums[i]+1, nums[i+1]-1])\n\n  if end &gt; nums[N-1]:\n    res.append([nums[N-1], end])\n\n  return res\n\nFindMissingRange([1, 2, 3, 4, 20, 30, 40, 99, 1000])\n\n[[0, 0], [5, 19], [21, 29], [31, 39], [41, 98], [100, 999]]\n\n\n\nfrom sortedcontainers import SortedDict\n\n\nclass MenuRecord():\n\n  def __init__(self, id, name, itemType, price=None, subItems=[]):\n    self.id = id\n    self.name = name\n    self.itemType = itemType\n    self.price = price\n    self.subItems = subItems\n\nclass MenuParser():\n\n  def __init__(self, menuStream):\n    self.menus = []\n    self.getNextItem = self.menuStream.get_next()\n\n  def parseSingleRecord(self):\n    pass\n\nclass MenuStream():\n\n  def __init__(self):\n    self.data = \"\"\"\n    1\n    Italian\n    CAT\n    2\n    3\n    --\n    2\n    Sphagetti\n    DISH\n    8.90\n    4\n    5\n    --\n    3\n    Salad\n    DISH\n    15.0\n    --\n    4\n    Cheese\n    Option\n    5.0\n    --\n    5\n    Dressing\n    Option\n    6.0\n    None\n    \"\"\"\n\n  def get_next(self):\n    lines = self.data.split()\n    print(lines)\n\n\nmstr = MenuStream()\nmstr.get_next()\n\n\n['1', 'Italian', 'CAT', '2', '3', '--', '2', 'Sphagetti', 'DISH', '8.90', '4', '5', '--', '3', 'Salad', 'DISH', '15.0', '--', '4', 'Cheese', 'Option', '5.0', '--', '5', 'Dressing', 'Option', '6.0', 'None']\n\n\n\nl = [[1,2],[3,4],[5,6]]\nlm = [i for i, j in l]\nprint(lm)\n\n[1, 3, 5]"
  },
  {
    "objectID": "posts/interview-prep/InterviewPrep.html#bipartite-graph-problems",
    "href": "posts/interview-prep/InterviewPrep.html#bipartite-graph-problems",
    "title": "Random Notes and Alogos",
    "section": "Bipartite Graph problems",
    "text": "Bipartite Graph problems\nDef: Given a graph we can divide the graphs into two independent groups such that every edge is between only two groups\nOther def: Two colorable\nThere is no cycle with odd length\nUsually the problems are related to add maximum edges between the two groups\nMCBM : Maximum Cardinality Bipartite Matching.\nAlogorithms:\n\nDfs Hopcroft-karp"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "sweblogs",
    "section": "",
    "text": "Random Notes and Alogos\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nswe design\n\n\n\n\n\n\n\n\n\nJul 31, 2024\n\n\nBasar C.\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJul 28, 2024\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  }
]